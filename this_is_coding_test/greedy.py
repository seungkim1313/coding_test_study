'''
당장 좋은 것만 선택하는 그리디

Greedy 알고리즘은 "현재 상황에서 지금 당장 좋은 것만 고르는 방법"을 말한다.
매순간 가장 좋은 방법을 선택하며, 현재의 선택이 나중에 미칠 영향은 신경쓰지 않는다.
'''

## 거스름돈
def change(n=1260):
    """ 거스름돈 문제
    손님에게 거슬러 줘야 할 돈이 N원일 때, 거슬러 줘야 할 동전의 최소 개수를 구하라.
    동전의 경우 500원, 100원, 50원, 10원이 있으며, 갯수는 무한이다.
    """
    count = 0
    
    coin_types = [500, 100, 50, 10]
    
    for coin in coin_types:
        count += n // coin
        n %= coin
    
    return count

'''
위와 같은 문제의 경우, 이렇게 greedy한 기법으로 해결할 수 있는 이유가
"큰 단위의 동전이 항상 작은 단위의 배수이기 때문에, 작은 동전들을 종합해 다른 해가 나올 수 없기 때문이다."
만약 동전이 500원 400원 100원 이런식으로 존재한다면, Greedy 방식으로 해결하지 못하는 케이스가 나올 수 있다.
(예: 800원 -> 500원 100월 100원 100원 vs. 400원 400원)
'''

## 큰 수의 법칙
def rule_of_large_number(num_list, n, m, k):
    """ 큰 수의 법칙
    다양한 수로 이루어진 배열이 있을 때, 주어진 수들을 M번 더하여 가장 큰 수를 만들어라.
    단, 배열에 특정 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더할 수 없다.
    """
    num_list.sort()
    num1 = num_list[n-1]
    num2 = num_list[n-2]
    
    count = int(m / (k + 1)) * k
    count += m % (k+1)
    
    result = 0
    result += (count) * num1
    result += (m - count) * num2
    
    return result

'''
해당 문제를 해결하려면 입력값 중에서 가장 큰 수와 다음으로 큰 수를 찾으면 해결된다.
왜냐하면 가장 큰수를 K번 만큼 더하고, 그 다음의 큰 수를 더한 뒤에 다시 가장 큰 수를 더하는 방식이 가장 큰 수로 만들 수 있는 방법이기 때문이다.
따라서 해당 문제에는 "반복되는 수열"이 존재한다.
예를 들어 num_list = [2, 4, 5, 4, 6] 이고, m 과 k 가 각각 8과 3이라고 생각을 해보면,
정답은 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5 가 된다. 
이는 "반복되는 수열"의 기리가 (k + 1)이라는 뜻이 되며, 해당 수열이 m / (k+1) 번 반복된다는 것을 알 수 있다.
단, m이 (k+1)으로 정확하게 나누어 떨어지지 않은 경우도 발생하는데, 남은 수 만큼 가장 큰 수가 추가로 더해진다.
따라서 '가장 큰 수가 더해지는 횟수'는 다음과 같다
(m / (k + 1)) * k + m % (k + 1)
위의 방법은 이와 같은 방법을 활용하여 해결한 코드다
'''


if __name__ == "__main__":
    answer = rule_of_large_number([2, 4, 5, 4, 6], 5, 8, 3)
    print(answer)